# 计算机网络

这里的笔记包含各种学习到的网络知识如：

- 相关书籍的学习（会以大标签的形式标注）
- 网络上的小知识
- 杂7杂8

# TCP

![image-20210603155057553](E:\images\image-20210603155057553.png)

## 概念

面向连接的、可靠的、基于字节流的传输层通信协议

## 解决问题

在IP协议之上，解决网络通讯可依赖问题

![image-20210603155913147](E:\images\image-20210603155913147.png)

## TCP任务

![image-20210603160303174](E:\images\image-20210603160303174.png)

## TCP四元组

- 源地址
- 源端口
- 目的地址
- 目的端口

## 三次握手

![image-20210603160927442](E:\images\image-20210603160927442.png)

## 报文格式

![image-20210604125652291](E:\images\image-20210604125652291.png)

格式说明：

首先TCP报文的头部占20个字节，以4个字节为一个部分划分为5个部分

1. 第一部分，源端口和目的端口字段	这里是端口号，IP那层在下面的

   - 源端口，占2个字节
   - 目的端口，占2个字节

2. 第二部分，序列号字段，占4个字节

   - Sequence Number 序列号字段，表示本报文段发送数据的第一个字节的编号。在 TCP  连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号；如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。（为什么会加1下面会说）

3. 第三部分，确认号字段，占4个字节

   - Acknowledgment Number 确认号字段，表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1。（这里说的很清楚，如果不清楚看下面的解析）

     > 以握手和发送数据的两个过程为例子，客户端为C，服务端为S
     >
     > 首先C向服务端发送第一次握手，根据ISN随机生成了一个seq 假设为100
     >
     > 然后服务器收到第一次握手后开始第二次握手，服务器也会根据自己的ISN随机生成一个服务端的seq，这里假设seq为200，并要进行进行数据的同步，要求ACK = C的seq +1 ，也就是101，这里意思表示期望该客户端发送的数据流的字节起始编号是101号开始，而这个操作就表示S告诉C，我收到你的握手请求了
     >
     > 第二次握手后C收到S的seq和ACK，这里的seq就是是服务器随机生成的为200，而收到的S的ACK为101，表示了服务器收到了，那将进行第三次握手，第三次握手C会发送一个ACK= S的seq+1，为201，这是在告诉服务器我也收到了
     >
     > 而上面客户端和服务端都只是处于一个建立连接的过程，但确认号ACK都加了1，就是因为在对方都收到了一个数据包中SYN或FIN标识为1的数据包，这就会触发ACK+1，目的就是用于同步和告诉对方，我收到了你的握手请求了
     >
     > 发送数据也如此，接着上面的握手的完后的数据继续解析，此时C的seq应该为101，因为上面握手的时候S的ACK为101，表示S期望收到C下一个发送的报文段的第一个数据编号，所以C的seq为101，而C发送的ACK为201，表示如果收到下一个报文中是有数据的应该是从201开始
     >
     > 如果在这期间，一直都是C向S发送数据，假设一共发送了3个报文，每个报文中的数据长度都为10个字节（3个 HelloWorld，16进制表示a），那期间的变化如下
     >
     > 1. C发送第一个报文，seq = 101，ACK = 201
     >    S返回一个收到，ACK = 101+a = 10b（**这里是16进制**）
     > 2. C发送第二个报文，seq = 10b，ACK = 201，ACK不变因为S没有发数据给C
     >    S返回一个收到，ACK = 10b+a = 115
     > 3. C发送第三个报文，seq = 115，ACK = 201，ACK还是不变
     >    S返回一个收到，ACK = 115+a = 11F
     >
     > 随后S发送了一个数据给C，内容为HelloClient，11个字节，16进制为b
     >
     > S发送报文，seq = 201，ACK =11f，表示S将会从101发送数据，并且期望下次从C收到的数据从11f开始。C收到数据后会返回一个收到，收到的数据长度为11字节，则返回一个ACK = 201+b = 20c

4. 第四部分，数据偏移字段，保留字段，标志位字段，窗口大小字段

   - 数据偏移字段，占4位，0.5个字节，指数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量，也就是确定TCP的头部长度，告诉接收端数据从何处开始
   - 保留字段，占4位，0.5个字节，为 TCP 将来的发展预留空间，目前必须全部为 0。
   - 标志位字段，一共有8个，占1个字节
     - CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。
     - ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。
     - URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。
     - ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。
     - PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。
     - RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。
     - SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1  时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。
     - FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接
   - 窗口大小字段，占2个字节，表示从 Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。

5. 第五部分，TCP校验和字段，紧急指针字段

   - TCP校验和字段，占2个字节，确认传输数据是否有损坏
   - 紧急指针字段，占2个字节，仅当URG标志位为1时才有意义，指出本数据段中为紧急数据的字节数，即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存

当然还有一个可选字段，长度不定但是必须是32位也就是4字节的整数倍

## 关于ISN

TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击

初始化序列号是随着时间变化的

## 滑动窗口

窗口”对应的是一段可以被发送的字节序列，其连续的范围称为窗口

“滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”

## 拥塞控制

*算法来的，先不管了*

# HTTP

超文本传输协议(HyperText Transfer Protocol)

HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

注意事项

- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

HTTP1.0定义了三种方法 GET，POST，HEAD

HTTP1.1新增加了6种方法

### 请求方法

- GET：请求指定的页面信息，并返回实体主体。
- HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
- POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
- PUT：从客户端向服务器传送的数据取代指定的文档的内容。
- DELETE：请求服务器删除指定的页面。
- CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
- OPTIONSP：允许客户端查看服务器的性能。
- TRACE：回显服务器收到的请求，主要用于测试或诊断。
- PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新 。

GET和POST

|                  | GET                                                          | POST                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
| 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |
| 缓存             | 能被缓存                                                     | 不能缓存                                                     |
| 编码类型         | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制。                                                     |
| 对数据类型的限制 | 只允许 ASCII 字符。                                          | 没有限制。也允许二进制数据。                                 |
| 安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。 在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
| 可见性           | 数据在 URL 中对所有人都是可见的。                            | 数据不会显示在 URL 中。                                      |

URL访问过程



# 抓包实战

## TCP三次握手

这里以python的socket连接作为例子，连接到云服务器

首先客户端请求连接到服务器，服务器处于监听状态

这里开始发起连接请求

![image-20210604172948931](E:\images\image-20210604172948931.png)

然后用Wireshark找到该连接的开始

![image-20210604173052278](E:\images\image-20210604173052278.png)

首先这里不难看到三次握手的记录

![image-20210604173116654](E:\images\image-20210604173116654.png)

在第一次握手中，客户端发送了SYN为1 以及随机生成的ISN用于seq

在第二次握手中，服务端返回自己的seq以及ACK，ACK = 客户端的seq+1，当标识为SYN的时候就会加1返回表示收到回复

在第三次握手中，客户端自己的seq，这个seq是第一次握手的时候加1的，ACK = 服务端的seq+1

状态图：

![TCP三次握手和四次挥手以及11种状态](E:\images\03c9baf005311c22581f6d4af4b2931b.png)

## 四次挥手

![image-20210608142204956](E:\images\image-20210608142204956.png)

以客户端发起挥手请求

![image-20210608142240702](E:\images\image-20210608142240702.png)

第一次挥手，FIN为1，带上seq为上次传输过后字节数的标号，这里是连接后立马断开，所以seq为ISN+1，同时期待下次收到的数据为ack，其实这里有ACK因为要收下次数据，这里ACK=1，这里假设seq = x

第二次挥手，为服务端收到了客户端的断开连接请求，但此时假设服务端还要传输数据给客户端，所以会先发一个ack以以及自己的seq给客户端告诉客户端表示收到了挥手请求，此时处于半连接状态，这里的ack为x+1，这里假设seq = y

第三次挥手由服务端发起，表示服务器也没有数据发送给客户端，需要断开连接，所以也需要发一个FIN为1，同时带上自己的seq和ack，此时的seq = y，因为没有传输过数据给客户端，ack在里不变因为没有来自客户端传输的数据了，所以还是x+1

第四次挥手，客户端收到了来自服务端的FIN，需要回传一个ACK，ack = y+1 而seq = x+1，然后经历两个2msl后客户端断开连接

状态图：

![TCP三次握手和四次挥手以及11种状态](E:\images\42aad4dccd487ffa8c782880c8ced56e.png)

## 面试题

### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

当S收到C的SYN报文后，可以直接发送SYN和ACK，SYN是同步，ACK是应答

关闭连接的时候S收到FIN报文时并不会立马关闭Socket，因为可能还有数据要传，所以只能先回复C一个ACK，只有等S这边所有的数据发送完毕了才能继续发送FIN报文，这一步需要拆开不能一起发送，所以需要四步

### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

以保守的态度，假象网络不可靠，有可能最后一个ack是丢失的（C发给S那个），而处于TIME_WAIT就是用来重发可能丢失了的ack报文，如果S没有收到这个ack会一直发送FIN报文给C，所以C不能马上关闭，需要等待两个MSL，第一个MSL是ack发送过去的时间，第二个MSL是S向C发送的FIN时间，加在一起就是两个MSL，如果在这期间又收到一个FIN则表面S没有收到ACK，所有C会重新发送一个ack，然后又开启一个2MSL的等待时间，直到没有收到服务器的数据后，就关闭处于CLOSED状态

### 为什么不能用两次握手进行连接？

*为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误*

*为了解决“网络中存在延迟的重复分组”的问题*

为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

三次握手中会完成两个重要的功能

- 双方做好发送数据的准备
- 双方初始序列号要进行协商确认

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP有一个保活计时器，服务器每收到一次客户端请求就会重新复位计时器，通常为2小时，2小时之后没有收到客户端的消息就会发一个探测报文，以后每隔75秒发一次，如果连续发送了10个探测报文都没有收到一个ack，服务器就会认为客户端发送故障，会自动关闭

# 杂7杂8

### 关于网络带宽

在实际的网络单位中，线路计算是按照 **比特（bit）** 进行计算的。但计算机的存储单位是按照 **字节（byte）** 来计算的，在实际中其演算的单位是：

```
1byte = 8bit
```

